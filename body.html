
<div class="body-div">
        <style>
            #videoElement{
            display: none;
        }
        </style>
        <div id="threejs_div"></div>
        <video autoplay="true" id="videoElement">	

        </video>
        <button onclick="gazePauser()">pause webgazer</button>
         <script type="module">
            //imports
                import * as THREE from '/libs/threejs/js/Three.js';
                import { FirstPersonControls } from '/libs/threejs/jsm/controls/FirstPersonControls.js';

                //variables
                let controls;
                const clock = new THREE.Clock();
                const render_window = document.querySelector("#threejs_div");
                //temp webcam 
            
                if(render_window == null){
                    render_window = document.querySelector("#threejs_div"); 
                }
            
                if(render_window != null)
                {
               
                var video = document.querySelector("#videoElement");
                //scaling
                if (navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia({ video: true })
                        .then(function (stream) {
                        video.srcObject = stream;
                        })
                        .catch(function (err0r) {
                        console.log("Something went wrong!");
                        });
                }
        
                //use div as texture
                const webcam_texture = new THREE.VideoTexture( video );
        
                //create scene
                var scene = new THREE.Scene();
                //create camera
                var camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth/window.innerHeight,0.1,1000
                )
        
                //set camera position
                camera.position.z = 5;
        
                var renderer = new THREE.WebGLRenderer({antialias: true});
                //set clear background
                renderer.setClearColor("#e5e5e5");
                //set renderer size 
                renderer.setSize(window.innerWidth,window.innerHeight);
                //add renderer to dom/html
                render_window.appendChild(renderer.domElement);
        
                //auto scale renderer on window resize
                window.addEventListener('resize', ()=>{
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    camera.aspect = window.innerWidth / window.innerHeight;
        
                    camera.updateProjectionMatrix();
                })
        
        
                //geometry sphere                       //radious, widt, height
                //var geometrySphere = new THREE.SphereGeometry(1, 4 ,4);
                //box geometry
                var geometryBox = new THREE.BoxGeometry(1, 1 ,1);
                var geometryPlane = new THREE.PlaneGeometry(1,1,1);
                //material
                var webcam_material = new THREE.MeshBasicMaterial({map: webcam_texture, side: THREE.SingleSide});
                var material_wall = new THREE.MeshLambertMaterial({color: "rgb(165, 182, 184)"});
                var material_ground = new THREE.MeshLambertMaterial({color: "rgb(176, 124, 67)"});
                var material_table = new THREE.MeshLambertMaterial({color: "rgb(255, 255, 255)"});
        
        
                //mesh
                var mesh_webcam1 = new THREE.Mesh(geometryPlane, webcam_material);
                var mesh_ground = new THREE.Mesh(geometryBox, material_ground);
                var mesh_wall = new THREE.Mesh(geometryBox, material_wall);
                var mesh_wall2 = new THREE.Mesh(geometryBox, material_wall);
                var mesh_wall3 = new THREE.Mesh(geometryBox, material_wall);
        
                var table_1 = new THREE.Mesh(geometryBox, material_table);
        
                //position
                mesh_webcam1.position.x = 2;
                mesh_ground.position.y = -2;
                mesh_wall.position.x = 4;
                mesh_wall2.position.x = -4;
                mesh_wall3.position.z = -4;
                table_1.position.z = 3;
                table_1.position.y = -1;
                //rotation
                mesh_webcam1.rotation.set(0,-0.5,0);
                mesh_wall3.rotation.set(0,0,0);
        
                //scale
                mesh_ground.scale.set(10,1,10);
                mesh_wall.scale.set(1,10,10);
                mesh_wall2.scale.set(1,10,10);
                mesh_wall3.scale.set(10,10,1);
                table_1.scale.set(2,1,5);
                //add object to scene
                scene.add(mesh_webcam1);
                scene.add(mesh_ground);
                scene.add(mesh_wall);
                scene.add(mesh_wall2);
                scene.add(mesh_wall3);
                scene.add(table_1);
        
                //create point light
                var light = new THREE.PointLight("rgb(255,255,255)", 1.5, 500);
                //directional light
                //const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
        
                //set light position
                light.position.set(0,1,0);
                //scene.add( directionalLight );
                scene.add(light);
        
                controls
                controls = new FirstPersonControls( camera, renderer.domElement );
                    controls.movementSpeed = 0;
        
                //set eventlistener mouse down
                render_window.addEventListener('mousedown', mouseDown, false);
                render_window.addEventListener('mouseup', mouseUp, false);
                
                controls.lookSpeed = 0;
        
                function mouseDown(){
                    controls.lookSpeed = 0.4;
                }
                function mouseUp(){
                    controls.lookSpeed = 0;
                }
                
                //call renderer to (re)render
                var render = function() {
                    requestAnimationFrame(render);
        
                    //mesh_webcam1.rotation.x += 0.01;
                    
                    //update controls
                    controls.update( clock.getDelta() );
        
                    //final render
                    renderer.render(scene, camera);
                }
        
                render();

                /////gaze
                camera.rotation.y = 0

                // devide screen into sections and return target section
                function deviser(cameraRotation){
                    // amount of devisions in the window
                    var divisions = 6;
                    var divisionSize = 180/divisions;
                    for(i = 0; i < divisions; i++){
                        if(cameraRotation >= (divisionSize*i) && cameraRotation <= (divisionSize*(i+1))){
                            // return center of devided space for the target rotation
                            return (((divisionSize*(i+1)) - (divisionSize*i) / 2) + (divisionSize*i)) - 90;
                        }
                    }
                }

                // pause eye tracking / TODO: add button on html page
                function gazePauser(){
                    var paused = false;

                    if(paused == true){
                        webgazer.resume();
                        paused = false;
                    }
                    if(paused == false){
                        webgazer.pause();
                        paused = true;
                    }
                }

                // animated rotation
                function rotateCam(targetRotation, degreeRotation, degree){
                    console.log("target degree rotation: " + targetRotation);
                    console.log("current degree rotation:" + degreeRotation);
                    console.log("current radian rotation: " + camera.rotation.y);
                    
                    if(degreeRotation < targetRotation){
                        if(targetRotation - 5 < degreeRotation && targetRotation + 5 > degreeRotation){
                            degreeRotation = targetRotation;
                        }
                        else{
                            camera.rotateY(-(degree * Math.PI / 180));
                        }
                    }
                    if(degreeRotation > targetRotation) {
                        if(targetRotation - 5 < degreeRotation && targetRotation + 5 > degreeRotation){
                            degreeRotation = targetRotation;
                        }
                        else{
                            camera.rotateY(degree * Math.PI / 180);
                        }
                    } 
                }

                // main webgazer loop
                webgazer.setGazeListener(function(data, timestamp) {
                    var windowWidth = window.innerWidth;
                    var windowCenter = windowWidth / 2;
                    var degreeRotation = camera.rotation.y * 180 / Math.PI;

                    try{
                        // main camera rotation
                        if(data.x < windowCenter){
                            var pixelPerRotation = 90*((windowCenter - data.x) / windowCenter);
                            rotateCam(deviser(degreeRotation - (degreeRotation - pixelPerRotation)), degreeRotation, 3);
                        }
                        if(data.x > windowCenter){
                            var pixelPerRotation = 90*((data.x - windowCenter) / windowCenter);
                            rotateCam(deviser(degreeRotation + (pixelPerRotation - degreeRotation)), degreeRotation, 3);
                        }        
                    }
                    catch{ }   
                }).begin();
            }
        </script>
</div> 
